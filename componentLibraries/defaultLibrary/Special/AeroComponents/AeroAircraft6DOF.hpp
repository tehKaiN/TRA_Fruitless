/*-----------------------------------------------------------------------------
 This source file is a part of Hopsan

 Copyright (c) 2009 to present year, Hopsan Group

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

 For license details and information about the Hopsan Group see the files
 GPLv3 and HOPSANGROUP in the Hopsan source code root directory

 For author and contributor information see the AUTHORS file
-----------------------------------------------------------------------------*/

#ifndef AEROAIRCRAFT6DOF_HPP_INCLUDED
#define AEROAIRCRAFT6DOF_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file AeroAircraft6DOF.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Wed 24 Apr 2013 16:00:12
//! @brief Flight dynamics model of aircraft
//! @ingroup AeroComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, C:, HopsanTrunk, HOPSAN++, CompgenModels}/AeroAircraft6DOFS.nb*/

using namespace hopsan;

class AeroAircraft6DOF : public ComponentC
{
private:
     double afin;
     double an1;
     double an2;
     double ap1;
     double ap2;
     double AR1;
     double AR2;
     double ARfin;
     double Cd01;
     double Cd02;
     double Cd0b;
     double Cd0fin;
     double CLalpha1;
     double CLalpha2;
     double CLalphabh;
     double CLalphabv;
     double CLalphafin;
     double CLde1;
     double CLde2;
     double CLde12;
     double Cdide1;
     double Cdide12;
     double Cdide112;
     double de10;
     double de120;
     double Cm01;
     double Cmfs1;
     double Cmde1;
     double Cmde12;
     double CLdefin;
     double dah1;
     double dah2;
     double e1;
     double e2;
     double efin;
     double awfin;
     double awn1;
     double awn2;
     double awp1;
     double awp2;
     double gamma1;
     double gamma2;
     double hthrust0;
     double ia1;
     double ia2;
     double Ix0;
     double Ixz0;
     double Iy0;
     double Iz0;
     double lambda1;
     double lambda2;
     double lambdafin;
     double lc10;
     double lc20;
     double lc120;
     double lcfin0;
     double Me;
     double rc10;
     double rc20;
     double rcfin0;
     double S1;
     double S20;
     double Sbh0;
     double Sbv0;
     double Sfin0;
     double xbach0;
     double xbacv0;
     double xbcge0;
     double xcargo0;
     double xfuel0;
     double xw10;
     double xw20;
     double xwfin0;
     double xeng0;
     double yeng0;
     double g0;
     double kground;
     double cground;
     Port *mpPal1;
     Port *mpPar1;
     Port *mpPal12;
     Port *mpPar12;
     Port *mpPal2;
     Port *mpPar2;
     Port *mpPfin;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     double delayParts5[9];
     double delayParts6[9];
     double delayParts7[9];
     double delayParts8[9];
     double delayParts9[9];
     double delayParts10[9];
     double delayParts11[9];
     double delayParts12[9];
     double delayParts13[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[13];
     int mNstep;
     //Port Pal1 variable
     double toral1;
     double thetaal1;
     double wal1;
     double cal1;
     double Zcal1;
     double eqInertiaal1;
     //Port Par1 variable
     double torar1;
     double thetaar1;
     double war1;
     double car1;
     double Zcar1;
     double eqInertiaar1;
     //Port Pal12 variable
     double toral12;
     double thetaal12;
     double wal12;
     double cal12;
     double Zcal12;
     double eqInertiaal12;
     //Port Par12 variable
     double torar12;
     double thetaar12;
     double war12;
     double car12;
     double Zcar12;
     double eqInertiaar12;
     //Port Pal2 variable
     double toral2;
     double thetaal2;
     double wal2;
     double cal2;
     double Zcal2;
     double eqInertiaal2;
     //Port Par2 variable
     double torar2;
     double thetaar2;
     double war2;
     double car2;
     double Zcar2;
     double eqInertiaar2;
     //Port Pfin variable
     double torfin;
     double thetafin;
     double wfin;
     double cfin;
     double Zcfin;
     double eqInertiafin;
//==This code has been autogenerated using Compgen==
     //inputVariables
     double thrustl;
     double thrustr;
     double dezthrustl;
     double dezthrustr;
     double deythrustl;
     double deythrustr;
     double Mfuel;
     double Mcargo;
     double rho;
     double vturbx;
     double vturby;
     double vturbz;
     double wturbx;
     double wturby;
     double wturbz;
     //outputVariables
     double xcg;
     double ycg;
     double zcg;
     double vx;
     double vy;
     double vz;
     double Psi;
     double Thetao;
     double Phi;
     double Ub;
     double Vb;
     double Wb;
     double Pb;
     double Qb;
     double Rb;
     double q0;
     double q1;
     double q2;
     double q3;
     double AlphaAttack;
     double BetaSlip;
     double altitude;
     double gfx;
     double gfy;
     double gfz;
     double CL1;
     double Cd1;
     double Fax;
     double Faz;
     //InitialExpressions variables
     //LocalExpressions variables
     double hthrust;
     double Ix;
     double Ixz;
     double Iy;
     double Iz;
     double lc1;
     double lc2;
     double lc12;
     double lcfin;
     double rc1;
     double rc2;
     double rcfin;
     double S2;
     double Sbh;
     double Sbv;
     double Sfin;
     double xbach;
     double xbacv;
     double xbcge;
     double xcargo;
     double xfuel;
     double xw1;
     double xw2;
     double xwfin;
     double xeng;
     double yeng;
     double v;
     double Alpha;
     double qpress;
     double Beta;
     double mass;
     double xbcg;
     double Dragl1;
     double Dragr1;
     double Liftl1;
     double Liftr1;
     double Dragl2;
     double Dragr2;
     double Liftl2;
     double Liftr2;
     double Liftb;
     double Dragb;
     double Cfin;
     double Dragfin;
     double Mdvtheta;
     double Mdvpsi;
     double Fx;
     double Fy;
     double Fz;
     double Lb;
     double Mb;
     double Nb;
     //Expressions variables
     //Port Pal1 pointer
     double *mpND_toral1;
     double *mpND_thetaal1;
     double *mpND_wal1;
     double *mpND_cal1;
     double *mpND_Zcal1;
     double *mpND_eqInertiaal1;
     //Port Par1 pointer
     double *mpND_torar1;
     double *mpND_thetaar1;
     double *mpND_war1;
     double *mpND_car1;
     double *mpND_Zcar1;
     double *mpND_eqInertiaar1;
     //Port Pal12 pointer
     double *mpND_toral12;
     double *mpND_thetaal12;
     double *mpND_wal12;
     double *mpND_cal12;
     double *mpND_Zcal12;
     double *mpND_eqInertiaal12;
     //Port Par12 pointer
     double *mpND_torar12;
     double *mpND_thetaar12;
     double *mpND_war12;
     double *mpND_car12;
     double *mpND_Zcar12;
     double *mpND_eqInertiaar12;
     //Port Pal2 pointer
     double *mpND_toral2;
     double *mpND_thetaal2;
     double *mpND_wal2;
     double *mpND_cal2;
     double *mpND_Zcal2;
     double *mpND_eqInertiaal2;
     //Port Par2 pointer
     double *mpND_torar2;
     double *mpND_thetaar2;
     double *mpND_war2;
     double *mpND_car2;
     double *mpND_Zcar2;
     double *mpND_eqInertiaar2;
     //Port Pfin pointer
     double *mpND_torfin;
     double *mpND_thetafin;
     double *mpND_wfin;
     double *mpND_cfin;
     double *mpND_Zcfin;
     double *mpND_eqInertiafin;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     double *mpthrustl;
     double *mpthrustr;
     double *mpdezthrustl;
     double *mpdezthrustr;
     double *mpdeythrustl;
     double *mpdeythrustr;
     double *mpMfuel;
     double *mpMcargo;
     double *mprho;
     double *mpvturbx;
     double *mpvturby;
     double *mpvturbz;
     double *mpwturbx;
     double *mpwturby;
     double *mpwturbz;
     //outputVariables pointers
     double *mpxcg;
     double *mpycg;
     double *mpzcg;
     double *mpvx;
     double *mpvy;
     double *mpvz;
     double *mpPsi;
     double *mpThetao;
     double *mpPhi;
     double *mpUb;
     double *mpVb;
     double *mpWb;
     double *mpPb;
     double *mpQb;
     double *mpRb;
     double *mpq0;
     double *mpq1;
     double *mpq2;
     double *mpq3;
     double *mpAlphaAttack;
     double *mpBetaSlip;
     double *mpaltitude;
     double *mpgfx;
     double *mpgfy;
     double *mpgfz;
     double *mpCL1;
     double *mpCd1;
     double *mpFax;
     double *mpFaz;
     Delay mDelayedPart10;
     Delay mDelayedPart11;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart30;
     Delay mDelayedPart31;
     Delay mDelayedPart40;
     Delay mDelayedPart41;
     Delay mDelayedPart50;
     Delay mDelayedPart51;
     Delay mDelayedPart60;
     Delay mDelayedPart61;
     Delay mDelayedPart70;
     Delay mDelayedPart71;
     Delay mDelayedPart80;
     Delay mDelayedPart81;
     Delay mDelayedPart90;
     Delay mDelayedPart91;
     Delay mDelayedPart100;
     Delay mDelayedPart101;
     Delay mDelayedPart110;
     Delay mDelayedPart111;
     Delay mDelayedPart120;
     Delay mDelayedPart121;
     Delay mDelayedPart130;
     Delay mDelayedPart131;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new AeroAircraft6DOF();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(13,13);
        systemEquations.create(13);
        delayedPart.create(14,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;


        //Add ports to the component
        mpPal1=addPowerPort("Pal1","NodeMechanicRotational");
        mpPar1=addPowerPort("Par1","NodeMechanicRotational");
        mpPal12=addPowerPort("Pal12","NodeMechanicRotational");
        mpPar12=addPowerPort("Par12","NodeMechanicRotational");
        mpPal2=addPowerPort("Pal2","NodeMechanicRotational");
        mpPar2=addPowerPort("Par2","NodeMechanicRotational");
        mpPfin=addPowerPort("Pfin","NodeMechanicRotational");
        //Add inputVariables to the component
            addInputVariable("thrustl","Engine thrust","N",0.,&mpthrustl);
            addInputVariable("thrustr","Engine thrust","N",0.,&mpthrustr);
            addInputVariable("dezthrustl","Thrust \
angle","rad",0.,&mpdezthrustl);
            addInputVariable("dezthrustr","Thrust \
angle","rad",0.,&mpdezthrustr);
            addInputVariable("deythrustl","Thrust \
angle","rad",0.,&mpdeythrustl);
            addInputVariable("deythrustr","Thrust \
angle","rad",0.,&mpdeythrustr);
            addInputVariable("Mfuel","Fuel weight","kg",0.,&mpMfuel);
            addInputVariable("Mcargo","Cargo weight","kg",0.,&mpMcargo);
            addInputVariable("rho","Air density","kg/m3",1.25,&mprho);
            addInputVariable("vturbx","air turbulence x","m/s",0.,&mpvturbx);
            addInputVariable("vturby","air turbulence y","m/s",0.,&mpvturby);
            addInputVariable("vturbz","air turbulence z","m/s",0.,&mpvturbz);
            addInputVariable("wturbx","air turbulence \
x","rad/s",0.,&mpwturbx);
            addInputVariable("wturby","air turbulence \
y","rad/s",0.,&mpwturby);
            addInputVariable("wturbz","air turbulence \
z","rad/s",0.,&mpwturbz);

        //Add outputVariables to the component
            addOutputVariable("xcg","Horizontal position 1","m",0,&mpxcg);
            addOutputVariable("ycg","Horizontal position 2","m",0,&mpycg);
            addOutputVariable("zcg","Vertical position","m",0,&mpzcg);
            addOutputVariable("vx","Horizontal speed 1","m",0,&mpvx);
            addOutputVariable("vy","Horizontal speed 2","m",0,&mpvy);
            addOutputVariable("vz","Vertical speed","m",0,&mpvz);
            addOutputVariable("Psi","Azimuth angle","rad",0,&mpPsi);
            addOutputVariable("Thetao","Elevation angle","rad",0,&mpThetao);
            addOutputVariable("Phi","Bank angle","rad",0,&mpPhi);
            addOutputVariable("Ub","Speed xb-axis","m/s",100,&mpUb);
            addOutputVariable("Vb","Speed yb-axis","m/s",0,&mpVb);
            addOutputVariable("Wb","Speed zb-axis","m/s",0,&mpWb);
            addOutputVariable("Pb","Angular velocity","rad/s",0,&mpPb);
            addOutputVariable("Qb","Angular velocity","rad/s",0,&mpQb);
            addOutputVariable("Rb","Angular velocity","rad/s",0,&mpRb);
            addOutputVariable("q0","quartenion 0","",0,&mpq0);
            addOutputVariable("q1","quartenion 1","",0,&mpq1);
            addOutputVariable("q2","quartenion 2","",0,&mpq2);
            addOutputVariable("q3","quartenion 3","",0,&mpq3);
            addOutputVariable("AlphaAttack","Angle of \
atack","rad",0,&mpAlphaAttack);
            addOutputVariable("BetaSlip","Sideslip \
angle","rad/s",0,&mpBetaSlip);
            addOutputVariable("altitude","altitude","m",0,&mpaltitude);
            addOutputVariable("gfx","g-force in x","m/s^2",0,&mpgfx);
            addOutputVariable("gfy","g-force in y","m/s^2",0,&mpgfy);
            addOutputVariable("gfz","g-force in z","m/s^2",0,&mpgfz);
            addOutputVariable("CL1","Lift coeff. wing 1","",0,&mpCL1);
            addOutputVariable("Cd1","Drag coeff. wing 1","",0,&mpCd1);
            addOutputVariable("Fax","{Fax, 0, double, Aero force in \
z}[[5]]","Aero force in z",0,&mpFax);
            addOutputVariable("Faz","{Faz, 0, double, Aero force in \
x}[[5]]","Aero force in x",0,&mpFaz);

//==This code has been autogenerated using Compgen==
        //Add constants/parameters
            addConstant("afin", "break angle 1", "rad", 0.3,afin);
            addConstant("an1", "Neg. break angle 1", "rad", 0.6,an1);
            addConstant("an2", "Neg. break angle 2", "rad", 0.6,an2);
            addConstant("ap1", "Pos. break angle 1", "rad", 0.9,ap1);
            addConstant("ap2", "Pos. break angle 2", "rad", 0.7,ap2);
            addConstant("AR1", "Aspect ratio 1", "", 2.24,AR1);
            addConstant("AR2", "Aspect rati 2o", "", 2.2,AR2);
            addConstant("ARfin", "Aspect ratio fin", "", 0.58,ARfin);
            addConstant("Cd01", "Drag coef. 1", "", 0.0045,Cd01);
            addConstant("Cd02", "Drag coef. 2", "", 0.0045,Cd02);
            addConstant("Cd0b", "Drag coef. body", "", 0.004,Cd0b);
            addConstant("Cd0fin", "Drag coef. fin", "", 0.0045,Cd0fin);
            addConstant("CLalpha1", "L. slope coef. 1", "", 2.1,CLalpha1);
            addConstant("CLalpha2", "L. slope coef. 2", "", 2.2,CLalpha2);
            addConstant("CLalphabh", "L. slope c. body h", "", 2.,CLalphabh);
            addConstant("CLalphabv", "L. slope c. bodyv", "", 2.,CLalphabv);
            addConstant("CLalphafin", "L. sl. c. fin", "", 0.8,CLalphafin);
            addConstant("CLde1", "Ctrl surface coef 1", "", 0.1,CLde1);
            addConstant("CLde2", "Ctrl surface coef 1", "", 0.515,CLde2);
            addConstant("CLde12", "Flap rudder coef 1", "", 0.2,CLde12);
            addConstant("Cdide1", "Flap rudder drag coef 1", "", 0.,Cdide1);
            addConstant("Cdide12", "Flap rudder drag coef 1", "", \
0.,Cdide12);
            addConstant("Cdide112", "Flap rudder cross drag coef 1", "", \
0.,Cdide112);
            addConstant("de10", "rudder min drag angle 1", "", 0.01,de10);
            addConstant("de120", "Flap min drag angle 1", "", 0.01,de120);
            addConstant("Cm01", "Mom coeff. wing 1", "", -0.1,Cm01);
            addConstant("Cmfs1", "Mom coeff.1, fully separated", "", \
-0.5,Cmfs1);
            addConstant("Cmde1", "Mom slop coeff 1", "", 0.02,Cmde1);
            addConstant("Cmde12", "Flap Mom slop coeff 1", "", 0.1,Cmde12);
            addConstant("CLdefin", "Rudder coef 1", "", 0.0827084,CLdefin);
            addConstant("dah1", "down wash effect on 1", "", 1.,dah1);
            addConstant("dah2", "down wash effect on 2", "", 0.6,dah2);
            addConstant("e1", "Osw. effic. factor 1", "", 0.95,e1);
            addConstant("e2", "Osw. effic. factor 1", "", 0.95,e2);
            addConstant("efin", "Osw. eff. f. fin", "", 0.95,efin);
            addConstant("awfin", "CL exponent fin", "", 0.2,awfin);
            addConstant("awn1", "CL exponent neg. 1", "", 0.2,awn1);
            addConstant("awn2", "CL exponent neg. 2", "", 0.2,awn2);
            addConstant("awp1", "CL exponent pos 1", "", 0.2,awp1);
            addConstant("awp2", "CL exponent neg 1", "", 0.2,awp2);
            addConstant("gamma1", "dehidral", "rad", -0.0872665,gamma1);
            addConstant("gamma2", "dehidral", "rad", -0.0872665,gamma2);
            addConstant("hthrust0", "engine vert. pos", "", 0.,hthrust0);
            addConstant("ia1", "incidence angle 1", "rad", 0.,ia1);
            addConstant("ia2", "incidence angle 1", " rad", 0.02,ia2);
            addConstant("Ix0", "Norm. Inertia moment Ix/(Me S1)", " ", \
0.0022,Ix0);
            addConstant("Ixz0", "Norm. Inertia moment", " ", 0.001,Ixz0);
            addConstant("Iy0", "Norm. Inertia moment", " ", 0.06,Iy0);
            addConstant("Iz0", "Inertia moment", " ", 0.08,Iz0);
            addConstant("lambda1", "sweep 1", "rad", 0.436332,lambda1);
            addConstant("lambda2", "sweep 2", "rad", 0.436332,lambda2);
            addConstant("lambdafin", "sweep fin", "rad", 0.785398,lambdafin);
            addConstant("lc10", "norm. ctrl surf. 1 ac fr hinge lc1/sqrt(AR1 \
S1)", "", 0.005,lc10);
            addConstant("lc20", "norm. ctrl surf. 2 ac fr hinge lc1/sqrt(AR1 \
S1)", "", 0.005,lc20);
            addConstant("lc120", "norm. flap 1 ac fr hinge", "", \
0.005,lc120);
            addConstant("lcfin0", "ctrl s. fin ac fr hinge", "", \
0.005,lcfin0);
            addConstant("Me", "Empty weight", "kg", 5000.,Me);
            addConstant("rc10", "norm. ctrl surface 1 mom. arm", "", \
0.25,rc10);
            addConstant("rc20", "norm. ctrl surface 1 mom. arm", "", \
0.15,rc20);
            addConstant("rcfin0", "norm. ctrl surf. fin mom. arm", "", \
0.1,rcfin0);
            addConstant("S1", "wing area 1", "m2", 40.,S1);
            addConstant("S20", "norm. wing area 2", "", 0.5,S20);
            addConstant("Sbh0", "norm. hor. proj. area", "", 0.2,Sbh0);
            addConstant("Sbv0", "norm.body vert. proj. area", "", 0.2,Sbv0);
            addConstant("Sfin0", "norm. fin area", "", 0.17,Sfin0);
            addConstant("xbach0", "norm. body ac. hor.", "", 2,xbach0);
            addConstant("xbacv0", "norm. body ac vert.", " ", 2,xbacv0);
            addConstant("xbcge0", "norm. body cg", " ", 1.4,xbcge0);
            addConstant("xcargo0", "norm. cargo pos.", " ", 1.4,xcargo0);
            addConstant("xfuel0", "", " ", 1.4,xfuel0);
            addConstant("xw10", "norm. wing1  position", " ", 1.55,xw10);
            addConstant("xw20", "norm. wing 2 position", " ", 2.6,xw20);
            addConstant("xwfin0", "norm. fin position", "", 2.6,xwfin0);
            addConstant("xeng0", "norm. fin position", "", 2.6,xeng0);
            addConstant("yeng0", "engines off. from center", "", 0.,yeng0);
            addConstant("g0", "Gravity acceleration", "m/s^2", 9.81,g0);
            addConstant("kground", "Ground stiffness (for limitiation)", \
"N/m", 10000.,kground);
            addConstant("cground", "Ground damping (for limitiation)", \
"Ns/m", 1000.,cground);
        mpSolver = new EquationSystemSolver(this,13);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pal1
        mpND_toral1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::Torque);
        mpND_thetaal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::Angle);
        mpND_wal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::AngularVelocity);
        mpND_cal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::EquivalentInertia);
        //Port Par1
        mpND_torar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::Torque);
        mpND_thetaar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::Angle);
        mpND_war1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::AngularVelocity);
        mpND_car1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::EquivalentInertia);
        //Port Pal12
        mpND_toral12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::Torque);
        mpND_thetaal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::Angle);
        mpND_wal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::AngularVelocity);
        mpND_cal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::EquivalentInertia);
        //Port Par12
        mpND_torar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::Torque);
        mpND_thetaar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::Angle);
        mpND_war12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::AngularVelocity);
        mpND_car12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::EquivalentInertia);
        //Port Pal2
        mpND_toral2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::Torque);
        mpND_thetaal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::Angle);
        mpND_wal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::AngularVelocity);
        mpND_cal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::EquivalentInertia);
        //Port Par2
        mpND_torar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::Torque);
        mpND_thetaar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::Angle);
        mpND_war2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::AngularVelocity);
        mpND_car2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::EquivalentInertia);
        //Port Pfin
        mpND_torfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::Torque);
        mpND_thetafin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::Angle);
        mpND_wfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::AngularVelocity);
        mpND_cfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiafin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::EquivalentInertia);

        //Read variables from nodes
        //Port Pal1
        toral1 = (*mpND_toral1);
        thetaal1 = (*mpND_thetaal1);
        wal1 = (*mpND_wal1);
        cal1 = (*mpND_cal1);
        Zcal1 = (*mpND_Zcal1);
        eqInertiaal1 = (*mpND_eqInertiaal1);
        //Port Par1
        torar1 = (*mpND_torar1);
        thetaar1 = (*mpND_thetaar1);
        war1 = (*mpND_war1);
        car1 = (*mpND_car1);
        Zcar1 = (*mpND_Zcar1);
        eqInertiaar1 = (*mpND_eqInertiaar1);
        //Port Pal12
        toral12 = (*mpND_toral12);
        thetaal12 = (*mpND_thetaal12);
        wal12 = (*mpND_wal12);
        cal12 = (*mpND_cal12);
        Zcal12 = (*mpND_Zcal12);
        eqInertiaal12 = (*mpND_eqInertiaal12);
        //Port Par12
        torar12 = (*mpND_torar12);
        thetaar12 = (*mpND_thetaar12);
        war12 = (*mpND_war12);
        car12 = (*mpND_car12);
        Zcar12 = (*mpND_Zcar12);
        eqInertiaar12 = (*mpND_eqInertiaar12);
        //Port Pal2
        toral2 = (*mpND_toral2);
        thetaal2 = (*mpND_thetaal2);
        wal2 = (*mpND_wal2);
        cal2 = (*mpND_cal2);
        Zcal2 = (*mpND_Zcal2);
        eqInertiaal2 = (*mpND_eqInertiaal2);
        //Port Par2
        torar2 = (*mpND_torar2);
        thetaar2 = (*mpND_thetaar2);
        war2 = (*mpND_war2);
        car2 = (*mpND_car2);
        Zcar2 = (*mpND_Zcar2);
        eqInertiaar2 = (*mpND_eqInertiaar2);
        //Port Pfin
        torfin = (*mpND_torfin);
        thetafin = (*mpND_thetafin);
        wfin = (*mpND_wfin);
        cfin = (*mpND_cfin);
        Zcfin = (*mpND_Zcfin);
        eqInertiafin = (*mpND_eqInertiafin);

        //Read inputVariables from nodes
        thrustl = (*mpthrustl);
        thrustr = (*mpthrustr);
        dezthrustl = (*mpdezthrustl);
        dezthrustr = (*mpdezthrustr);
        deythrustl = (*mpdeythrustl);
        deythrustr = (*mpdeythrustr);
        Mfuel = (*mpMfuel);
        Mcargo = (*mpMcargo);
        rho = (*mprho);
        vturbx = (*mpvturbx);
        vturby = (*mpvturby);
        vturbz = (*mpvturbz);
        wturbx = (*mpwturbx);
        wturby = (*mpwturby);
        wturbz = (*mpwturbz);

        //Read outputVariables from nodes
        xcg = (*mpxcg);
        ycg = (*mpycg);
        zcg = (*mpzcg);
        vx = (*mpvx);
        vy = (*mpvy);
        vz = (*mpvz);
        Psi = (*mpPsi);
        Thetao = (*mpThetao);
        Phi = (*mpPhi);
        Ub = (*mpUb);
        Vb = (*mpVb);
        Wb = (*mpWb);
        Pb = (*mpPb);
        Qb = (*mpQb);
        Rb = (*mpRb);
        q0 = (*mpq0);
        q1 = (*mpq1);
        q2 = (*mpq2);
        q3 = (*mpq3);
        AlphaAttack = (*mpAlphaAttack);
        BetaSlip = (*mpBetaSlip);
        altitude = (*mpaltitude);
        gfx = (*mpgfx);
        gfy = (*mpgfy);
        gfz = (*mpgfz);
        CL1 = (*mpCL1);
        Cd1 = (*mpCd1);
        Fax = (*mpFax);
        Faz = (*mpFaz);

//==This code has been autogenerated using Compgen==
        //InitialExpressions
        q0 = Cos(Phi/2.)*Cos(Psi/2.)*Cos(Thetao/2.) + \
Sin(Phi/2.)*Sin(Psi/2.)*Sin(Thetao/2.);
        q1 = Cos(Psi/2.)*Cos(Thetao/2.)*Sin(Phi/2.) - \
Cos(Phi/2.)*Sin(Psi/2.)*Sin(Thetao/2.);
        q2 = Cos(Thetao/2.)*Sin(Phi/2.)*Sin(Psi/2.) + \
Cos(Phi/2.)*Cos(Psi/2.)*Sin(Thetao/2.);
        q3 = Cos(Phi/2.)*Cos(Thetao/2.)*Sin(Psi/2.) - \
Cos(Psi/2.)*Sin(Phi/2.)*Sin(Thetao/2.);

        //LocalExpressions
        hthrust = hthrust0*Sqrt(S1);
        Ix = AR1*Ix0*Me*S1;
        Ixz = AR1*Ixz0*Me*S1;
        Iy = Iy0*Me*S1;
        Iz = (Iz0*Me*S1)/AR1;
        lc1 = lc10*Sqrt(S1/AR1);
        lc2 = lc20*Sqrt(S1/AR1);
        lc12 = lc120*Sqrt(S1/AR1);
        lcfin = lcfin0*Sqrt(S1/AR1);
        rc1 = rc10*Sqrt(AR1*S1);
        rc2 = rc20*Sqrt(AR1*S1);
        rcfin = rcfin0*Sqrt(S1/AR1);
        S2 = S1*S20;
        Sbh = S1*Sbh0;
        Sbv = S1*Sbv0;
        Sfin = S1*Sfin0;
        xbach = Sqrt(S1/AR1)*xbach0;
        xbacv = Sqrt(S1/AR1)*xbacv0;
        xbcge = Sqrt(S1/AR1)*xbcge0;
        xcargo = Sqrt(S1/AR1)*xcargo0;
        xfuel = Sqrt(S1/AR1)*xfuel0;
        xw1 = Sqrt(S1/AR1)*xw10;
        xw2 = Sqrt(S1/AR1)*xw20;
        xwfin = Sqrt(S1/AR1)*xwfin0;
        xeng = Sqrt(AR1*S1)*xeng0;
        yeng = Sqrt(AR1*S1)*yeng0;
        v = Sqrt(0.0001 + Power(Ub + vturbx,2) + Power(Vb + vturby,2) + \
Power(vturbz + Wb,2));
        Alpha = Atan2L(vturbz + Wb,0.0001 + Ub + vturbx);
        qpress = (rho*Power(v,2))/2.;
        Beta = Atan2L(Vb + vturby,Sqrt(0.0001 + Power(Ub + vturbx,2) + \
Power(vturbz + Wb,2)));
        mass = Mcargo + Me + Mfuel;
        xbcg = (Me*xbcge + Mcargo*xcargo + Mfuel*xfuel)/mass;
        Dragl1 = qpress*S1*(Cd01/2. + Cdide1*Power(-de10 + thetaal1,2) - \
Cdide112*(-de10 + thetaal1)*(-de120 + thetaal12) + Cdide12*Power(-de120 + \
thetaal12,2) + CDragInd(Alpha*dah1 - \
ia1,AR1,e1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Dragr1 = qpress*S1*(Cd01/2. + Cdide1*Power(-de10 + thetaar1,2) - \
Cdide112*(-de10 + thetaar1)*(-de120 + thetaar12) + Cdide12*Power(-de120 + \
thetaar12,2) + CDragInd(Alpha*dah1 - \
ia1,AR1,e1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Liftl1 = qpress*S1*(CLde1*thetaal1 + CLde12*thetaal12 + \
CLift(Alpha*dah1 - ia1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Liftr1 = qpress*S1*(CLde1*thetaar1 + CLde12*thetaar12 + \
CLift(Alpha*dah1 - ia1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Dragl2 = qpress*S2*(Cd02/2. + CDragInd(Alpha*dah2 - \
ia2,AR2,e2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Dragr2 = qpress*S2*(Cd02/2. + CDragInd(Alpha*dah2 - \
ia2,AR2,e2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Liftl2 = qpress*S2*(CLde2*thetaal2 + CLift(Alpha*dah2 - \
ia2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Liftr2 = qpress*S2*(CLde2*thetaar2 + CLift(Alpha*dah2 - \
ia2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Liftb = CLalphabh*qpress*Sbh*Sin(Alpha);
        Dragb = Cd0b*qpress*Sbh;
        Cfin = qpress*Sfin*CLift(-Beta - \
(CLdefin*thetafin)/CLalphafin,CLalphafin,afin,afin,awfin,awfin);
        Dragfin = Cd0fin*qpress*Sfin;
        Mdvtheta = (CLalpha2*qpress*S2*Power(-xbcg + xw2,2))/(0.1 + v);
        Mdvpsi = (CLalphafin*qpress*Sfin*Power(-xbcg + xwfin,2))/(0.1 + v);
        Fx = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - \
Dragr2)*Cos(Alpha)*Cos(Beta) + thrustl*Cos(deythrustl)*Cos(dezthrustr) + \
thrustl*Cos(deythrustr)*Cos(dezthrustr) - (-Liftb - Liftl1 - Liftl2 - Liftr1 \
- Liftr2)*Sin(Alpha) - Cos(Alpha)*Sin(Beta)*(-Cfin + \
CLalphabv*qpress*Sbv*Sin(Beta));
        Fy = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2)*Sin(Beta) \
+ Cos(Beta)*(-Cfin + CLalphabv*qpress*Sbv*Sin(Beta)) - \
thrustl*Cos(dezthrustr)*Sin(deythrustl) - \
thrustl*Cos(dezthrustr)*Sin(deythrustr);
        Fz = (-Liftb - Liftl1 - Liftl2 - Liftr1 - Liftr2)*Cos(Alpha) - \
kground*zcg*onPositive(zcg) + (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - \
Dragr2)*Cos(Beta)*Sin(Alpha) - Sin(Alpha)*Sin(Beta)*(-Cfin + \
CLalphabv*qpress*Sbv*Sin(Beta)) - thrustl*Cos(deythrustl)*Sin(dezthrustr) - \
thrustl*Cos(deythrustr)*Sin(dezthrustr);
        Lb = ((Liftl1 - Liftr1)*rc1 + (Liftl2 - Liftr2)*rc2 - \
(0.12249999999999998*qpress*(AR1*CLalpha1*Power(S1,2) + \
AR2*CLalpha2*Power(S2,2))*(Pb + wturbx))/(0.1 + v))*Cos(Alpha)*Cos(Beta) - \
Sin(Alpha)*(-(Mdvpsi*(Rb + wturbz)) - Cfin*(-xbcg + xwfin) + rc1*((-Dragl1 + \
Dragr1)*Cos(Alpha) + (-Liftl1 + Liftr1)*Sin(Alpha)) + rc2*((-Dragl2 + \
Dragr2)*Cos(Alpha) + (-Liftl2 + Liftr2)*Sin(Alpha))) - \
Cos(Alpha)*(-(Mdvtheta*(Qb + wturby)) + qpress*S1*(-(Cmde1*thetaal1) - \
Cmde12*thetaal12 - Cmde1*thetaar1 - Cmde12*thetaar12 + CMoment(Alpha*dah1 - \
ia1,Cm01,Cmfs1,ap1,an1,awp1,awn1)) + (xbcg - xw1)*((Liftl1 + \
Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + (xbcg - xw2)*((Liftl2 + \
Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha)))*Sin(Beta) + \
yeng*(thrustl*Cos(deythrustl)*Sin(dezthrustl) - \
thrustr*Cos(deythrustr)*Sin(dezthrustr));
        Mb = Cos(Beta)*(-(Mdvtheta*(Qb + wturby)) + \
qpress*S1*(-(Cmde1*thetaal1) - Cmde12*thetaal12 - Cmde1*thetaar1 - \
Cmde12*thetaar12 + CMoment(Alpha*dah1 - ia1,Cm01,Cmfs1,ap1,an1,awp1,awn1)) + \
(xbcg - xw1)*((Liftl1 + Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + \
(xbcg - xw2)*((Liftl2 + Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha))) + \
((Liftl1 - Liftr1)*rc1 + (Liftl2 - Liftr2)*rc2 - \
(0.12249999999999998*qpress*(AR1*CLalpha1*Power(S1,2) + \
AR2*CLalpha2*Power(S2,2))*(Pb + wturbx))/(0.1 + v))*Sin(Beta) + (xbcg - \
xeng)*(thrustl*Cos(deythrustl)*Sin(dezthrustl) + \
thrustr*Cos(deythrustr)*Sin(dezthrustr));
        Nb = ((Liftl1 - Liftr1)*rc1 + (Liftl2 - Liftr2)*rc2 - \
(0.12249999999999998*qpress*(AR1*CLalpha1*Power(S1,2) + \
AR2*CLalpha2*Power(S2,2))*(Pb + wturbx))/(0.1 + v))*Cos(Beta)*Sin(Alpha) + \
Cos(Alpha)*(-(Mdvpsi*(Rb + wturbz)) - Cfin*(-xbcg + xwfin) + rc1*((-Dragl1 + \
Dragr1)*Cos(Alpha) + (-Liftl1 + Liftr1)*Sin(Alpha)) + rc2*((-Dragl2 + \
Dragr2)*Cos(Alpha) + (-Liftl2 + Liftr2)*Sin(Alpha))) - \
Sin(Alpha)*(-(Mdvtheta*(Qb + wturby)) + qpress*S1*(-(Cmde1*thetaal1) - \
Cmde12*thetaal12 - Cmde1*thetaar1 - Cmde12*thetaar12 + CMoment(Alpha*dah1 - \
ia1,Cm01,Cmfs1,ap1,an1,awp1,awn1)) + (xbcg - xw1)*((Liftl1 + \
Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + (xbcg - xw2)*((Liftl2 + \
Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha)))*Sin(Beta) + (xbcg - \
xeng)*(thrustl*Cos(dezthrustl)*Sin(deythrustl) + \
thrustr*Cos(dezthrustr)*Sin(deythrustr));

        //Initialize delays
        delayParts1[1] = (-(Fx*mTimestep) + 2*g0*mass*mTimestep*q0*q2 - \
2*g0*mass*mTimestep*q1*q3 - 2*mass*Ub - mass*mTimestep*Rb*Vb + \
mass*mTimestep*Qb*Wb - 2*kground*mTimestep*q0*q2*zcg*onPositive(zcg) + \
2*kground*mTimestep*q1*q3*zcg*onPositive(zcg))/(2.*mass);
        mDelayedPart11.initialize(mNstep,delayParts1[1]);
        delayParts2[1] = (-(Fy*mTimestep) - 2*g0*mass*mTimestep*q0*q1 - \
2*g0*mass*mTimestep*q2*q3 + mass*mTimestep*Rb*Ub - 2*mass*Vb - \
mass*mTimestep*Pb*Wb + 2*kground*mTimestep*q0*q1*zcg*onPositive(zcg) + \
2*kground*mTimestep*q2*q3*zcg*onPositive(zcg))/(2.*mass);
        mDelayedPart21.initialize(mNstep,delayParts2[1]);
        delayParts3[1] = (-(Fz*mTimestep) - g0*mass*mTimestep*Power(q0,2) + \
g0*mass*mTimestep*Power(q1,2) + g0*mass*mTimestep*Power(q2,2) - \
g0*mass*mTimestep*Power(q3,2) - mass*mTimestep*Qb*Ub + mass*mTimestep*Pb*Vb - \
2*mass*Wb + kground*mTimestep*Power(q0,2)*zcg*onPositive(zcg) - \
kground*mTimestep*Power(q1,2)*zcg*onPositive(zcg) - \
kground*mTimestep*Power(q2,2)*zcg*onPositive(zcg) + \
kground*mTimestep*Power(q3,2)*zcg*onPositive(zcg))/(2.*mass);
        mDelayedPart31.initialize(mNstep,delayParts3[1]);
        delayParts4[1] = (Iz*Lb*mTimestep + Ixz*mTimestep*Nb - \
2*Power(Ixz,2)*Pb + 2*Ix*Iz*Pb + Ix*Ixz*mTimestep*Pb*Qb - \
Ixz*Iy*mTimestep*Pb*Qb + Ixz*Iz*mTimestep*Pb*Qb - \
Power(Ixz,2)*mTimestep*Qb*Rb + Iy*Iz*mTimestep*Qb*Rb - \
Power(Iz,2)*mTimestep*Qb*Rb)/(2*Power(Ixz,2) - 2*Ix*Iz + Ix*Ixz*mTimestep*Qb \
- Ixz*Iy*mTimestep*Qb + Ixz*Iz*mTimestep*Qb);
        mDelayedPart41.initialize(mNstep,delayParts4[1]);
        delayParts5[1] = (-(Mb*mTimestep) + Ixz*mTimestep*Power(Pb,2) - \
2*Iy*Qb + Ix*mTimestep*Pb*Rb - Iz*mTimestep*Pb*Rb - \
Ixz*mTimestep*Power(Rb,2))/(2.*Iy);
        mDelayedPart51.initialize(mNstep,delayParts5[1]);
        delayParts6[1] = (Ixz*Lb*mTimestep + Ix*mTimestep*Nb + \
Power(Ix,2)*mTimestep*Pb*Qb + Power(Ixz,2)*mTimestep*Pb*Qb - \
Ix*Iy*mTimestep*Pb*Qb - 2*Power(Ixz,2)*Rb + 2*Ix*Iz*Rb - \
Ix*Ixz*mTimestep*Qb*Rb + Ixz*Iy*mTimestep*Qb*Rb - \
Ixz*Iz*mTimestep*Qb*Rb)/(2*Power(Ixz,2) - 2*Ix*Iz - Ix*Ixz*mTimestep*Qb + \
Ixz*Iy*mTimestep*Qb - Ixz*Iz*mTimestep*Qb);
        mDelayedPart61.initialize(mNstep,delayParts6[1]);
        delayParts7[1] = (-4*q0 + mTimestep*Pb*q1 + mTimestep*q2*Qb + \
mTimestep*q3*Rb)/4.;
        mDelayedPart71.initialize(mNstep,delayParts7[1]);
        delayParts8[1] = (-(mTimestep*Pb*q0) - 4*q1 + mTimestep*q3*Qb - \
mTimestep*q2*Rb)/4.;
        mDelayedPart81.initialize(mNstep,delayParts8[1]);
        delayParts9[1] = (-4*q2 - mTimestep*Pb*q3 - mTimestep*q0*Qb + \
mTimestep*q1*Rb)/4.;
        mDelayedPart91.initialize(mNstep,delayParts9[1]);
        delayParts10[1] = (mTimestep*Pb*q2 - 4*q3 - mTimestep*q1*Qb - \
mTimestep*q0*Rb)/4.;
        mDelayedPart101.initialize(mNstep,delayParts10[1]);
        delayParts11[1] = (-(mTimestep*Power(q0,2)*Ub) - \
mTimestep*Power(q1,2)*Ub + mTimestep*Power(q2,2)*Ub + \
mTimestep*Power(q3,2)*Ub - 2*mTimestep*q1*q2*Vb + 2*mTimestep*q0*q3*Vb - \
2*mTimestep*q0*q2*Wb - 2*mTimestep*q1*q3*Wb - 2*xcg)/2.;
        mDelayedPart111.initialize(mNstep,delayParts11[1]);
        delayParts12[1] = (-2*mTimestep*q1*q2*Ub - 2*mTimestep*q0*q3*Ub - \
mTimestep*Power(q0,2)*Vb + mTimestep*Power(q1,2)*Vb - \
mTimestep*Power(q2,2)*Vb + mTimestep*Power(q3,2)*Vb + 2*mTimestep*q0*q1*Wb - \
2*mTimestep*q2*q3*Wb - 2*ycg)/2.;
        mDelayedPart121.initialize(mNstep,delayParts12[1]);
        delayParts13[1] = (2*mTimestep*q0*q2*Ub - 2*mTimestep*q1*q3*Ub - \
2*mTimestep*q0*q1*Vb - 2*mTimestep*q2*q3*Vb - mTimestep*Power(q0,2)*Wb + \
mTimestep*Power(q1,2)*Wb + mTimestep*Power(q2,2)*Wb - \
mTimestep*Power(q3,2)*Wb - 2*zcg)/2.;
        mDelayedPart131.initialize(mNstep,delayParts13[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
        delayedPart[8][1] = delayParts8[1];
        delayedPart[9][1] = delayParts9[1];
        delayedPart[10][1] = delayParts10[1];
        delayedPart[11][1] = delayParts11[1];
        delayedPart[12][1] = delayParts12[1];
        delayedPart[13][1] = delayParts13[1];
     }
    void simulateOneTimestep()
     {
        Vec stateVar(13);
        Vec stateVark(13);
        Vec deltaStateVar(13);

        //Read variables from nodes
        //Port Pal1
        toral1 = (*mpND_toral1);
        thetaal1 = (*mpND_thetaal1);
        wal1 = (*mpND_wal1);
        eqInertiaal1 = (*mpND_eqInertiaal1);
        //Port Par1
        torar1 = (*mpND_torar1);
        thetaar1 = (*mpND_thetaar1);
        war1 = (*mpND_war1);
        eqInertiaar1 = (*mpND_eqInertiaar1);
        //Port Pal12
        toral12 = (*mpND_toral12);
        thetaal12 = (*mpND_thetaal12);
        wal12 = (*mpND_wal12);
        eqInertiaal12 = (*mpND_eqInertiaal12);
        //Port Par12
        torar12 = (*mpND_torar12);
        thetaar12 = (*mpND_thetaar12);
        war12 = (*mpND_war12);
        eqInertiaar12 = (*mpND_eqInertiaar12);
        //Port Pal2
        toral2 = (*mpND_toral2);
        thetaal2 = (*mpND_thetaal2);
        wal2 = (*mpND_wal2);
        eqInertiaal2 = (*mpND_eqInertiaal2);
        //Port Par2
        torar2 = (*mpND_torar2);
        thetaar2 = (*mpND_thetaar2);
        war2 = (*mpND_war2);
        eqInertiaar2 = (*mpND_eqInertiaar2);
        //Port Pfin
        torfin = (*mpND_torfin);
        thetafin = (*mpND_thetafin);
        wfin = (*mpND_wfin);
        eqInertiafin = (*mpND_eqInertiafin);

        //Read inputVariables from nodes
        thrustl = (*mpthrustl);
        thrustr = (*mpthrustr);
        dezthrustl = (*mpdezthrustl);
        dezthrustr = (*mpdezthrustr);
        deythrustl = (*mpdeythrustl);
        deythrustr = (*mpdeythrustr);
        Mfuel = (*mpMfuel);
        Mcargo = (*mpMcargo);
        rho = (*mprho);
        vturbx = (*mpvturbx);
        vturby = (*mpvturby);
        vturbz = (*mpvturbz);
        wturbx = (*mpwturbx);
        wturby = (*mpwturby);
        wturbz = (*mpwturbz);

        //LocalExpressions
        hthrust = hthrust0*Sqrt(S1);
        Ix = AR1*Ix0*Me*S1;
        Ixz = AR1*Ixz0*Me*S1;
        Iy = Iy0*Me*S1;
        Iz = (Iz0*Me*S1)/AR1;
        lc1 = lc10*Sqrt(S1/AR1);
        lc2 = lc20*Sqrt(S1/AR1);
        lc12 = lc120*Sqrt(S1/AR1);
        lcfin = lcfin0*Sqrt(S1/AR1);
        rc1 = rc10*Sqrt(AR1*S1);
        rc2 = rc20*Sqrt(AR1*S1);
        rcfin = rcfin0*Sqrt(S1/AR1);
        S2 = S1*S20;
        Sbh = S1*Sbh0;
        Sbv = S1*Sbv0;
        Sfin = S1*Sfin0;
        xbach = Sqrt(S1/AR1)*xbach0;
        xbacv = Sqrt(S1/AR1)*xbacv0;
        xbcge = Sqrt(S1/AR1)*xbcge0;
        xcargo = Sqrt(S1/AR1)*xcargo0;
        xfuel = Sqrt(S1/AR1)*xfuel0;
        xw1 = Sqrt(S1/AR1)*xw10;
        xw2 = Sqrt(S1/AR1)*xw20;
        xwfin = Sqrt(S1/AR1)*xwfin0;
        xeng = Sqrt(AR1*S1)*xeng0;
        yeng = Sqrt(AR1*S1)*yeng0;
        v = Sqrt(0.0001 + Power(Ub + vturbx,2) + Power(Vb + vturby,2) + \
Power(vturbz + Wb,2));
        Alpha = Atan2L(vturbz + Wb,0.0001 + Ub + vturbx);
        qpress = (rho*Power(v,2))/2.;
        Beta = Atan2L(Vb + vturby,Sqrt(0.0001 + Power(Ub + vturbx,2) + \
Power(vturbz + Wb,2)));
        mass = Mcargo + Me + Mfuel;
        xbcg = (Me*xbcge + Mcargo*xcargo + Mfuel*xfuel)/mass;
        Dragl1 = qpress*S1*(Cd01/2. + Cdide1*Power(-de10 + thetaal1,2) - \
Cdide112*(-de10 + thetaal1)*(-de120 + thetaal12) + Cdide12*Power(-de120 + \
thetaal12,2) + CDragInd(Alpha*dah1 - \
ia1,AR1,e1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Dragr1 = qpress*S1*(Cd01/2. + Cdide1*Power(-de10 + thetaar1,2) - \
Cdide112*(-de10 + thetaar1)*(-de120 + thetaar12) + Cdide12*Power(-de120 + \
thetaar12,2) + CDragInd(Alpha*dah1 - \
ia1,AR1,e1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Liftl1 = qpress*S1*(CLde1*thetaal1 + CLde12*thetaal12 + \
CLift(Alpha*dah1 - ia1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Liftr1 = qpress*S1*(CLde1*thetaar1 + CLde12*thetaar12 + \
CLift(Alpha*dah1 - ia1,CLalpha1,ap1,an1,awp1,awn1)/2.);
        Dragl2 = qpress*S2*(Cd02/2. + CDragInd(Alpha*dah2 - \
ia2,AR2,e2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Dragr2 = qpress*S2*(Cd02/2. + CDragInd(Alpha*dah2 - \
ia2,AR2,e2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Liftl2 = qpress*S2*(CLde2*thetaal2 + CLift(Alpha*dah2 - \
ia2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Liftr2 = qpress*S2*(CLde2*thetaar2 + CLift(Alpha*dah2 - \
ia2,CLalpha2,ap2,an2,awp2,awn2)/2.);
        Liftb = CLalphabh*qpress*Sbh*Sin(Alpha);
        Dragb = Cd0b*qpress*Sbh;
        Cfin = qpress*Sfin*CLift(-Beta - \
(CLdefin*thetafin)/CLalphafin,CLalphafin,afin,afin,awfin,awfin);
        Dragfin = Cd0fin*qpress*Sfin;
        Mdvtheta = (CLalpha2*qpress*S2*Power(-xbcg + xw2,2))/(0.1 + v);
        Mdvpsi = (CLalphafin*qpress*Sfin*Power(-xbcg + xwfin,2))/(0.1 + v);
        Fx = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - \
Dragr2)*Cos(Alpha)*Cos(Beta) + thrustl*Cos(deythrustl)*Cos(dezthrustr) + \
thrustl*Cos(deythrustr)*Cos(dezthrustr) - (-Liftb - Liftl1 - Liftl2 - Liftr1 \
- Liftr2)*Sin(Alpha) - Cos(Alpha)*Sin(Beta)*(-Cfin + \
CLalphabv*qpress*Sbv*Sin(Beta));
        Fy = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2)*Sin(Beta) \
+ Cos(Beta)*(-Cfin + CLalphabv*qpress*Sbv*Sin(Beta)) - \
thrustl*Cos(dezthrustr)*Sin(deythrustl) - \
thrustl*Cos(dezthrustr)*Sin(deythrustr);
        Fz = (-Liftb - Liftl1 - Liftl2 - Liftr1 - Liftr2)*Cos(Alpha) - \
kground*zcg*onPositive(zcg) + (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - \
Dragr2)*Cos(Beta)*Sin(Alpha) - Sin(Alpha)*Sin(Beta)*(-Cfin + \
CLalphabv*qpress*Sbv*Sin(Beta)) - thrustl*Cos(deythrustl)*Sin(dezthrustr) - \
thrustl*Cos(deythrustr)*Sin(dezthrustr);
        Lb = ((Liftl1 - Liftr1)*rc1 + (Liftl2 - Liftr2)*rc2 - \
(0.12249999999999998*qpress*(AR1*CLalpha1*Power(S1,2) + \
AR2*CLalpha2*Power(S2,2))*(Pb + wturbx))/(0.1 + v))*Cos(Alpha)*Cos(Beta) - \
Sin(Alpha)*(-(Mdvpsi*(Rb + wturbz)) - Cfin*(-xbcg + xwfin) + rc1*((-Dragl1 + \
Dragr1)*Cos(Alpha) + (-Liftl1 + Liftr1)*Sin(Alpha)) + rc2*((-Dragl2 + \
Dragr2)*Cos(Alpha) + (-Liftl2 + Liftr2)*Sin(Alpha))) - \
Cos(Alpha)*(-(Mdvtheta*(Qb + wturby)) + qpress*S1*(-(Cmde1*thetaal1) - \
Cmde12*thetaal12 - Cmde1*thetaar1 - Cmde12*thetaar12 + CMoment(Alpha*dah1 - \
ia1,Cm01,Cmfs1,ap1,an1,awp1,awn1)) + (xbcg - xw1)*((Liftl1 + \
Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + (xbcg - xw2)*((Liftl2 + \
Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha)))*Sin(Beta) + \
yeng*(thrustl*Cos(deythrustl)*Sin(dezthrustl) - \
thrustr*Cos(deythrustr)*Sin(dezthrustr));
        Mb = Cos(Beta)*(-(Mdvtheta*(Qb + wturby)) + \
qpress*S1*(-(Cmde1*thetaal1) - Cmde12*thetaal12 - Cmde1*thetaar1 - \
Cmde12*thetaar12 + CMoment(Alpha*dah1 - ia1,Cm01,Cmfs1,ap1,an1,awp1,awn1)) + \
(xbcg - xw1)*((Liftl1 + Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + \
(xbcg - xw2)*((Liftl2 + Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha))) + \
((Liftl1 - Liftr1)*rc1 + (Liftl2 - Liftr2)*rc2 - \
(0.12249999999999998*qpress*(AR1*CLalpha1*Power(S1,2) + \
AR2*CLalpha2*Power(S2,2))*(Pb + wturbx))/(0.1 + v))*Sin(Beta) + (xbcg - \
xeng)*(thrustl*Cos(deythrustl)*Sin(dezthrustl) + \
thrustr*Cos(deythrustr)*Sin(dezthrustr));
        Nb = ((Liftl1 - Liftr1)*rc1 + (Liftl2 - Liftr2)*rc2 - \
(0.12249999999999998*qpress*(AR1*CLalpha1*Power(S1,2) + \
AR2*CLalpha2*Power(S2,2))*(Pb + wturbx))/(0.1 + v))*Cos(Beta)*Sin(Alpha) + \
Cos(Alpha)*(-(Mdvpsi*(Rb + wturbz)) - Cfin*(-xbcg + xwfin) + rc1*((-Dragl1 + \
Dragr1)*Cos(Alpha) + (-Liftl1 + Liftr1)*Sin(Alpha)) + rc2*((-Dragl2 + \
Dragr2)*Cos(Alpha) + (-Liftl2 + Liftr2)*Sin(Alpha))) - \
Sin(Alpha)*(-(Mdvtheta*(Qb + wturby)) + qpress*S1*(-(Cmde1*thetaal1) - \
Cmde12*thetaal12 - Cmde1*thetaar1 - Cmde12*thetaar12 + CMoment(Alpha*dah1 - \
ia1,Cm01,Cmfs1,ap1,an1,awp1,awn1)) + (xbcg - xw1)*((Liftl1 + \
Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + (xbcg - xw2)*((Liftl2 + \
Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha)))*Sin(Beta) + (xbcg - \
xeng)*(thrustl*Cos(dezthrustl)*Sin(deythrustl) + \
thrustr*Cos(dezthrustr)*Sin(deythrustr));

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = Ub;
        stateVark[1] = Vb;
        stateVark[2] = Wb;
        stateVark[3] = Pb;
        stateVark[4] = Qb;
        stateVark[5] = Rb;
        stateVark[6] = q0;
        stateVark[7] = q1;
        stateVark[8] = q2;
        stateVark[9] = q3;
        stateVark[10] = xcg;
        stateVark[11] = ycg;
        stateVark[12] = zcg;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //Aircraft6DOF
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =Ub - (mTimestep*(Fx + mass*(-2*g0*q0*q2 + \
2*g0*q1*q3 + Rb*Vb - Qb*Wb) + 2*kground*(q0*q2 - \
q1*q3)*zcg*onPositive(zcg)))/(2.*mass) + delayedPart[1][1];
          systemEquations[1] =Vb - (mTimestep*(Fy + mass*(2*g0*q0*q1 + \
2*g0*q2*q3 - Rb*Ub + Pb*Wb) - 2*kground*(q0*q1 + \
q2*q3)*zcg*onPositive(zcg)))/(2.*mass) + delayedPart[2][1];
          systemEquations[2] =Wb - (mTimestep*(Fz + mass*(g0*(Power(q0,2) - \
Power(q1,2) - Power(q2,2) + Power(q3,2)) + Qb*Ub - Pb*Vb) + \
kground*(-Power(q0,2) + Power(q1,2) + Power(q2,2) - \
Power(q3,2))*zcg*onPositive(zcg)))/(2.*mass) + delayedPart[3][1];
          systemEquations[3] =Pb + (mTimestep*(-(Power(Iz,2)*Qb*Rb) + Ixz*(Nb \
- Ixz*Qb*Rb) + Iz*(Lb + Iy*Qb*Rb)))/(2*Power(Ixz,2) - 2*Ix*Iz + Ixz*(Ix - Iy \
+ Iz)*mTimestep*Qb) + delayedPart[4][1];
          systemEquations[4] =Qb - (mTimestep*(Mb + (-Ix + Iz)*Pb*Rb + \
Ixz*(-Power(Pb,2) + Power(Rb,2))))/(2.*Iy) + delayedPart[5][1];
          systemEquations[5] =-((mTimestep*(Ixz*Lb + Power(Ixz,2)*Pb*Qb + \
Ix*(Nb + (Ix - Iy)*Pb*Qb)))/(-2*Power(Ixz,2) + 2*Ix*Iz + Ixz*(Ix - Iy + \
Iz)*mTimestep*Qb)) + Rb + delayedPart[6][1];
          systemEquations[6] =q0 + (mTimestep*(Pb*q1 + q2*Qb + q3*Rb))/4. + \
delayedPart[7][1];
          systemEquations[7] =q1 - (mTimestep*(Pb*q0 - q3*Qb + q2*Rb))/4. + \
delayedPart[8][1];
          systemEquations[8] =q2 - (mTimestep*(Pb*q3 + q0*Qb - q1*Rb))/4. + \
delayedPart[9][1];
          systemEquations[9] =q3 + (mTimestep*(Pb*q2 - q1*Qb - q0*Rb))/4. + \
delayedPart[10][1];
          systemEquations[10] =-(mTimestep*(Power(q0,2)*Ub + Power(q1,2)*Ub - \
(Power(q2,2) + Power(q3,2))*Ub + q0*(-2*q3*Vb + 2*q2*Wb) + 2*q1*(q2*Vb + \
q3*Wb)))/2. + xcg + delayedPart[11][1];
          systemEquations[11] =(mTimestep*(-2*q1*q2*Ub - 2*q0*q3*Ub - \
Power(q0,2)*Vb + Power(q1,2)*Vb - Power(q2,2)*Vb + Power(q3,2)*Vb + \
2*q0*q1*Wb - 2*q2*q3*Wb))/2. + ycg + delayedPart[12][1];
          systemEquations[12] =-(mTimestep*(-2*q0*q2*Ub + 2*q1*q3*Ub + \
2*q0*q1*Vb + 2*q2*q3*Vb + Power(q0,2)*Wb - Power(q1,2)*Wb - Power(q2,2)*Wb + \
Power(q3,2)*Wb))/2. + zcg + delayedPart[13][1];

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = -(mTimestep*Rb)/2.;
          jacobianMatrix[0][2] = (mTimestep*Qb)/2.;
          jacobianMatrix[0][3] = 0;
          jacobianMatrix[0][4] = (mTimestep*Wb)/2.;
          jacobianMatrix[0][5] = -(mTimestep*Vb)/2.;
          jacobianMatrix[0][6] = -(mTimestep*(-2*g0*mass*q2 + \
2*kground*q2*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][7] = -(mTimestep*(2*g0*mass*q3 - \
2*kground*q3*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][8] = -(mTimestep*(-2*g0*mass*q0 + \
2*kground*q0*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][9] = -(mTimestep*(2*g0*mass*q1 - \
2*kground*q1*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][10] = 0;
          jacobianMatrix[0][11] = 0;
          jacobianMatrix[0][12] = -((kground*mTimestep*(q0*q2 - \
q1*q3)*onPositive(zcg))/mass);
          jacobianMatrix[1][0] = (mTimestep*Rb)/2.;
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = -(mTimestep*Pb)/2.;
          jacobianMatrix[1][3] = -(mTimestep*Wb)/2.;
          jacobianMatrix[1][4] = 0;
          jacobianMatrix[1][5] = (mTimestep*Ub)/2.;
          jacobianMatrix[1][6] = -(mTimestep*(2*g0*mass*q1 - \
2*kground*q1*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][7] = -(mTimestep*(2*g0*mass*q0 - \
2*kground*q0*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][8] = -(mTimestep*(2*g0*mass*q3 - \
2*kground*q3*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][9] = -(mTimestep*(2*g0*mass*q2 - \
2*kground*q2*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][10] = 0;
          jacobianMatrix[1][11] = 0;
          jacobianMatrix[1][12] = (kground*mTimestep*(q0*q1 + \
q2*q3)*onPositive(zcg))/mass;
          jacobianMatrix[2][0] = -(mTimestep*Qb)/2.;
          jacobianMatrix[2][1] = (mTimestep*Pb)/2.;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = (mTimestep*Vb)/2.;
          jacobianMatrix[2][4] = -(mTimestep*Ub)/2.;
          jacobianMatrix[2][5] = 0;
          jacobianMatrix[2][6] = -(mTimestep*(2*g0*mass*q0 - \
2*kground*q0*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][7] = -(mTimestep*(-2*g0*mass*q1 + \
2*kground*q1*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][8] = -(mTimestep*(-2*g0*mass*q2 + \
2*kground*q2*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][9] = -(mTimestep*(2*g0*mass*q3 - \
2*kground*q3*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][10] = 0;
          jacobianMatrix[2][11] = 0;
          jacobianMatrix[2][12] = -(kground*mTimestep*(-Power(q0,2) + \
Power(q1,2) + Power(q2,2) - Power(q3,2))*onPositive(zcg))/(2.*mass);
          jacobianMatrix[3][0] = 0;
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = 0;
          jacobianMatrix[3][3] = 1;
          jacobianMatrix[3][4] = (mTimestep*(-(Power(Ixz,2)*Rb) + Iy*Iz*Rb - \
Power(Iz,2)*Rb))/(2*Power(Ixz,2) - 2*Ix*Iz + Ixz*(Ix - Iy + Iz)*mTimestep*Qb) \
- (Ixz*(Ix - Iy + Iz)*Power(mTimestep,2)*(-(Power(Iz,2)*Qb*Rb) + Ixz*(Nb - \
Ixz*Qb*Rb) + Iz*(Lb + Iy*Qb*Rb)))/Power(2*Power(Ixz,2) - 2*Ix*Iz + Ixz*(Ix - \
Iy + Iz)*mTimestep*Qb,2);
          jacobianMatrix[3][5] = (mTimestep*(-(Power(Ixz,2)*Qb) + Iy*Iz*Qb - \
Power(Iz,2)*Qb))/(2*Power(Ixz,2) - 2*Ix*Iz + Ixz*(Ix - Iy + \
Iz)*mTimestep*Qb);
          jacobianMatrix[3][6] = 0;
          jacobianMatrix[3][7] = 0;
          jacobianMatrix[3][8] = 0;
          jacobianMatrix[3][9] = 0;
          jacobianMatrix[3][10] = 0;
          jacobianMatrix[3][11] = 0;
          jacobianMatrix[3][12] = 0;
          jacobianMatrix[4][0] = 0;
          jacobianMatrix[4][1] = 0;
          jacobianMatrix[4][2] = 0;
          jacobianMatrix[4][3] = -(mTimestep*(-2*Ixz*Pb + (-Ix + \
Iz)*Rb))/(2.*Iy);
          jacobianMatrix[4][4] = 1;
          jacobianMatrix[4][5] = -(mTimestep*((-Ix + Iz)*Pb + \
2*Ixz*Rb))/(2.*Iy);
          jacobianMatrix[4][6] = 0;
          jacobianMatrix[4][7] = 0;
          jacobianMatrix[4][8] = 0;
          jacobianMatrix[4][9] = 0;
          jacobianMatrix[4][10] = 0;
          jacobianMatrix[4][11] = 0;
          jacobianMatrix[4][12] = 0;
          jacobianMatrix[5][0] = 0;
          jacobianMatrix[5][1] = 0;
          jacobianMatrix[5][2] = 0;
          jacobianMatrix[5][3] = -((mTimestep*(Power(Ixz,2)*Qb + Ix*(Ix - \
Iy)*Qb))/(-2*Power(Ixz,2) + 2*Ix*Iz + Ixz*(Ix - Iy + Iz)*mTimestep*Qb));
          jacobianMatrix[5][4] = -((mTimestep*(Power(Ixz,2)*Pb + Ix*(Ix - \
Iy)*Pb))/(-2*Power(Ixz,2) + 2*Ix*Iz + Ixz*(Ix - Iy + Iz)*mTimestep*Qb)) + \
(Ixz*(Ix - Iy + Iz)*Power(mTimestep,2)*(Ixz*Lb + Power(Ixz,2)*Pb*Qb + Ix*(Nb \
+ (Ix - Iy)*Pb*Qb)))/Power(-2*Power(Ixz,2) + 2*Ix*Iz + Ixz*(Ix - Iy + \
Iz)*mTimestep*Qb,2);
          jacobianMatrix[5][5] = 1;
          jacobianMatrix[5][6] = 0;
          jacobianMatrix[5][7] = 0;
          jacobianMatrix[5][8] = 0;
          jacobianMatrix[5][9] = 0;
          jacobianMatrix[5][10] = 0;
          jacobianMatrix[5][11] = 0;
          jacobianMatrix[5][12] = 0;
          jacobianMatrix[6][0] = 0;
          jacobianMatrix[6][1] = 0;
          jacobianMatrix[6][2] = 0;
          jacobianMatrix[6][3] = (mTimestep*q1)/4.;
          jacobianMatrix[6][4] = (mTimestep*q2)/4.;
          jacobianMatrix[6][5] = (mTimestep*q3)/4.;
          jacobianMatrix[6][6] = 1;
          jacobianMatrix[6][7] = (mTimestep*Pb)/4.;
          jacobianMatrix[6][8] = (mTimestep*Qb)/4.;
          jacobianMatrix[6][9] = (mTimestep*Rb)/4.;
          jacobianMatrix[6][10] = 0;
          jacobianMatrix[6][11] = 0;
          jacobianMatrix[6][12] = 0;
          jacobianMatrix[7][0] = 0;
          jacobianMatrix[7][1] = 0;
          jacobianMatrix[7][2] = 0;
          jacobianMatrix[7][3] = -(mTimestep*q0)/4.;
          jacobianMatrix[7][4] = (mTimestep*q3)/4.;
          jacobianMatrix[7][5] = -(mTimestep*q2)/4.;
          jacobianMatrix[7][6] = -(mTimestep*Pb)/4.;
          jacobianMatrix[7][7] = 1;
          jacobianMatrix[7][8] = -(mTimestep*Rb)/4.;
          jacobianMatrix[7][9] = (mTimestep*Qb)/4.;
          jacobianMatrix[7][10] = 0;
          jacobianMatrix[7][11] = 0;
          jacobianMatrix[7][12] = 0;
          jacobianMatrix[8][0] = 0;
          jacobianMatrix[8][1] = 0;
          jacobianMatrix[8][2] = 0;
          jacobianMatrix[8][3] = -(mTimestep*q3)/4.;
          jacobianMatrix[8][4] = -(mTimestep*q0)/4.;
          jacobianMatrix[8][5] = (mTimestep*q1)/4.;
          jacobianMatrix[8][6] = -(mTimestep*Qb)/4.;
          jacobianMatrix[8][7] = (mTimestep*Rb)/4.;
          jacobianMatrix[8][8] = 1;
          jacobianMatrix[8][9] = -(mTimestep*Pb)/4.;
          jacobianMatrix[8][10] = 0;
          jacobianMatrix[8][11] = 0;
          jacobianMatrix[8][12] = 0;
          jacobianMatrix[9][0] = 0;
          jacobianMatrix[9][1] = 0;
          jacobianMatrix[9][2] = 0;
          jacobianMatrix[9][3] = (mTimestep*q2)/4.;
          jacobianMatrix[9][4] = -(mTimestep*q1)/4.;
          jacobianMatrix[9][5] = -(mTimestep*q0)/4.;
          jacobianMatrix[9][6] = -(mTimestep*Rb)/4.;
          jacobianMatrix[9][7] = -(mTimestep*Qb)/4.;
          jacobianMatrix[9][8] = (mTimestep*Pb)/4.;
          jacobianMatrix[9][9] = 1;
          jacobianMatrix[9][10] = 0;
          jacobianMatrix[9][11] = 0;
          jacobianMatrix[9][12] = 0;
          jacobianMatrix[10][0] = -(mTimestep*(Power(q0,2) + Power(q1,2) - \
Power(q2,2) - Power(q3,2)))/2.;
          jacobianMatrix[10][1] = -(mTimestep*(2*q1*q2 - 2*q0*q3))/2.;
          jacobianMatrix[10][2] = -(mTimestep*(2*q0*q2 + 2*q1*q3))/2.;
          jacobianMatrix[10][3] = 0;
          jacobianMatrix[10][4] = 0;
          jacobianMatrix[10][5] = 0;
          jacobianMatrix[10][6] = -(mTimestep*(2*q0*Ub - 2*q3*Vb + \
2*q2*Wb))/2.;
          jacobianMatrix[10][7] = -(mTimestep*(2*q1*Ub + 2*(q2*Vb + \
q3*Wb)))/2.;
          jacobianMatrix[10][8] = -(mTimestep*(-2*q2*Ub + 2*q1*Vb + \
2*q0*Wb))/2.;
          jacobianMatrix[10][9] = -(mTimestep*(-2*q3*Ub - 2*q0*Vb + \
2*q1*Wb))/2.;
          jacobianMatrix[10][10] = 1;
          jacobianMatrix[10][11] = 0;
          jacobianMatrix[10][12] = 0;
          jacobianMatrix[11][0] = (mTimestep*(-2*q1*q2 - 2*q0*q3))/2.;
          jacobianMatrix[11][1] = (mTimestep*(-Power(q0,2) + Power(q1,2) - \
Power(q2,2) + Power(q3,2)))/2.;
          jacobianMatrix[11][2] = (mTimestep*(2*q0*q1 - 2*q2*q3))/2.;
          jacobianMatrix[11][3] = 0;
          jacobianMatrix[11][4] = 0;
          jacobianMatrix[11][5] = 0;
          jacobianMatrix[11][6] = (mTimestep*(-2*q3*Ub - 2*q0*Vb + \
2*q1*Wb))/2.;
          jacobianMatrix[11][7] = (mTimestep*(-2*q2*Ub + 2*q1*Vb + \
2*q0*Wb))/2.;
          jacobianMatrix[11][8] = (mTimestep*(-2*q1*Ub - 2*q2*Vb - \
2*q3*Wb))/2.;
          jacobianMatrix[11][9] = (mTimestep*(-2*q0*Ub + 2*q3*Vb - \
2*q2*Wb))/2.;
          jacobianMatrix[11][10] = 0;
          jacobianMatrix[11][11] = 1;
          jacobianMatrix[11][12] = 0;
          jacobianMatrix[12][0] = -(mTimestep*(-2*q0*q2 + 2*q1*q3))/2.;
          jacobianMatrix[12][1] = -(mTimestep*(2*q0*q1 + 2*q2*q3))/2.;
          jacobianMatrix[12][2] = -(mTimestep*(Power(q0,2) - Power(q1,2) - \
Power(q2,2) + Power(q3,2)))/2.;
          jacobianMatrix[12][3] = 0;
          jacobianMatrix[12][4] = 0;
          jacobianMatrix[12][5] = 0;
          jacobianMatrix[12][6] = -(mTimestep*(-2*q2*Ub + 2*q1*Vb + \
2*q0*Wb))/2.;
          jacobianMatrix[12][7] = -(mTimestep*(2*q3*Ub + 2*q0*Vb - \
2*q1*Wb))/2.;
          jacobianMatrix[12][8] = -(mTimestep*(-2*q0*Ub + 2*q3*Vb - \
2*q2*Wb))/2.;
          jacobianMatrix[12][9] = -(mTimestep*(2*q1*Ub + 2*q2*Vb + \
2*q3*Wb))/2.;
          jacobianMatrix[12][10] = 0;
          jacobianMatrix[12][11] = 0;
          jacobianMatrix[12][12] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          Ub=stateVark[0];
          Vb=stateVark[1];
          Wb=stateVark[2];
          Pb=stateVark[3];
          Qb=stateVark[4];
          Rb=stateVark[5];
          q0=stateVark[6];
          q1=stateVark[7];
          q2=stateVark[8];
          q3=stateVark[9];
          xcg=stateVark[10];
          ycg=stateVark[11];
          zcg=stateVark[12];
          //Expressions
          cal1 = CLde1*Power(lc1,2)*qpress*S1*(-Alpha + thetaal1);
          car1 = CLde1*Power(lc1,2)*qpress*S1*(-Alpha + thetaar1);
          cal12 = CLde12*Power(lc12,2)*qpress*S1*(-Alpha + thetaal12);
          car12 = CLde12*Power(lc12,2)*qpress*S1*(-Alpha + thetaar12);
          cal2 = CLde2*Power(lc2,2)*qpress*S2*(-Alpha + thetaal2);
          car2 = CLde2*Power(lc2,2)*qpress*S2*(-Alpha + thetaar2);
          cfin = CLdefin*Power(lcfin,2)*qpress*Sfin*(-Beta + thetafin);
          vx = (Power(q0,2) + Power(q1,2) - Power(q2,2) - Power(q3,2))*Ub + \
2*(q1*q2 - q0*q3)*Vb + 2*(q0*q2 + q1*q3)*Wb;
          vy = 2*(q1*q2 + q0*q3)*Ub + (Power(q0,2) - Power(q1,2) + \
Power(q2,2) - Power(q3,2))*Vb + 2*(-(q0*q1) + q2*q3)*Wb;
          vz = 2*(-(q0*q2) + q1*q3)*Ub + 2*(q0*q1 + q2*q3)*Vb + (Power(q0,2) \
- Power(q1,2) - Power(q2,2) + Power(q3,2))*Wb;
          AlphaAttack = Alpha;
          BetaSlip = Beta;
          altitude = -zcg;
          Phi = Atan2L(2*(q0*q1 + q2*q3),Power(q0,2) - Power(q1,2) - \
Power(q2,2) + Power(q3,2));
          Thetao = ArcSinL(2*(q0*q2 - q1*q3));
          Psi = Atan2L(2*(q1*q2 + q0*q3),Power(q0,2) + Power(q1,2) - \
Power(q2,2) - Power(q3,2));
          gfx = Fx/mass;
          gfy = Fy/mass;
          gfz = Fz/mass;
          Faz = -Liftb - Liftl1 - Liftl2 - Liftr1 - Liftr2;
          Fax = -Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2;
          CL1 = CLde1*thetaal1 + CLde12*thetaal12 + CLde1*thetaar1 + \
CLde12*thetaar12 + CLift(Alpha*dah1 - ia1,CLalpha1,ap1,an1,awp1,awn1);
          Cd1 = Cd01 + Cdide1*Power(-de10 + thetaal1,2) - Cdide112*(-de10 + \
thetaal1)*(-de120 + thetaal12) + Cdide12*Power(-de120 + thetaal12,2) + \
Cdide1*Power(-de10 + thetaar1,2) - Cdide112*(-de10 + thetaar1)*(-de120 + \
thetaar12) + Cdide12*Power(-de120 + thetaar12,2) + CDragInd(Alpha*dah1 - \
ia1,AR1,e1,CLalpha1,ap1,an1,awp1,awn1);
          Zcfin = CLdefin*Power(lcfin,2)*mTimestep*qpress*Sfin;
          Zcal1 = CLde1*Power(lc1,2)*mTimestep*qpress*S1;
          Zcar1 = CLde1*Power(lc1,2)*mTimestep*qpress*S1;
          Zcal12 = CLde12*Power(lc12,2)*mTimestep*qpress*S1;
          Zcar12 = CLde12*Power(lc12,2)*mTimestep*qpress*S1;
          Zcal2 = CLde2*Power(lc2,2)*mTimestep*qpress*S2;
          Zcar2 = CLde2*Power(lc2,2)*mTimestep*qpress*S2;
        }

        //Calculate the delayed parts
        delayParts1[1] = (-(Fx*mTimestep) + 2*g0*mass*mTimestep*q0*q2 - \
2*g0*mass*mTimestep*q1*q3 - 2*mass*Ub - mass*mTimestep*Rb*Vb + \
mass*mTimestep*Qb*Wb - 2*kground*mTimestep*q0*q2*zcg*onPositive(zcg) + \
2*kground*mTimestep*q1*q3*zcg*onPositive(zcg))/(2.*mass);
        delayParts2[1] = (-(Fy*mTimestep) - 2*g0*mass*mTimestep*q0*q1 - \
2*g0*mass*mTimestep*q2*q3 + mass*mTimestep*Rb*Ub - 2*mass*Vb - \
mass*mTimestep*Pb*Wb + 2*kground*mTimestep*q0*q1*zcg*onPositive(zcg) + \
2*kground*mTimestep*q2*q3*zcg*onPositive(zcg))/(2.*mass);
        delayParts3[1] = (-(Fz*mTimestep) - g0*mass*mTimestep*Power(q0,2) + \
g0*mass*mTimestep*Power(q1,2) + g0*mass*mTimestep*Power(q2,2) - \
g0*mass*mTimestep*Power(q3,2) - mass*mTimestep*Qb*Ub + mass*mTimestep*Pb*Vb - \
2*mass*Wb + kground*mTimestep*Power(q0,2)*zcg*onPositive(zcg) - \
kground*mTimestep*Power(q1,2)*zcg*onPositive(zcg) - \
kground*mTimestep*Power(q2,2)*zcg*onPositive(zcg) + \
kground*mTimestep*Power(q3,2)*zcg*onPositive(zcg))/(2.*mass);
        delayParts4[1] = (Iz*Lb*mTimestep + Ixz*mTimestep*Nb - \
2*Power(Ixz,2)*Pb + 2*Ix*Iz*Pb + Ix*Ixz*mTimestep*Pb*Qb - \
Ixz*Iy*mTimestep*Pb*Qb + Ixz*Iz*mTimestep*Pb*Qb - \
Power(Ixz,2)*mTimestep*Qb*Rb + Iy*Iz*mTimestep*Qb*Rb - \
Power(Iz,2)*mTimestep*Qb*Rb)/(2*Power(Ixz,2) - 2*Ix*Iz + Ix*Ixz*mTimestep*Qb \
- Ixz*Iy*mTimestep*Qb + Ixz*Iz*mTimestep*Qb);
        delayParts5[1] = (-(Mb*mTimestep) + Ixz*mTimestep*Power(Pb,2) - \
2*Iy*Qb + Ix*mTimestep*Pb*Rb - Iz*mTimestep*Pb*Rb - \
Ixz*mTimestep*Power(Rb,2))/(2.*Iy);
        delayParts6[1] = (Ixz*Lb*mTimestep + Ix*mTimestep*Nb + \
Power(Ix,2)*mTimestep*Pb*Qb + Power(Ixz,2)*mTimestep*Pb*Qb - \
Ix*Iy*mTimestep*Pb*Qb - 2*Power(Ixz,2)*Rb + 2*Ix*Iz*Rb - \
Ix*Ixz*mTimestep*Qb*Rb + Ixz*Iy*mTimestep*Qb*Rb - \
Ixz*Iz*mTimestep*Qb*Rb)/(2*Power(Ixz,2) - 2*Ix*Iz - Ix*Ixz*mTimestep*Qb + \
Ixz*Iy*mTimestep*Qb - Ixz*Iz*mTimestep*Qb);
        delayParts7[1] = (-4*q0 + mTimestep*Pb*q1 + mTimestep*q2*Qb + \
mTimestep*q3*Rb)/4.;
        delayParts8[1] = (-(mTimestep*Pb*q0) - 4*q1 + mTimestep*q3*Qb - \
mTimestep*q2*Rb)/4.;
        delayParts9[1] = (-4*q2 - mTimestep*Pb*q3 - mTimestep*q0*Qb + \
mTimestep*q1*Rb)/4.;
        delayParts10[1] = (mTimestep*Pb*q2 - 4*q3 - mTimestep*q1*Qb - \
mTimestep*q0*Rb)/4.;
        delayParts11[1] = (-(mTimestep*Power(q0,2)*Ub) - \
mTimestep*Power(q1,2)*Ub + mTimestep*Power(q2,2)*Ub + \
mTimestep*Power(q3,2)*Ub - 2*mTimestep*q1*q2*Vb + 2*mTimestep*q0*q3*Vb - \
2*mTimestep*q0*q2*Wb - 2*mTimestep*q1*q3*Wb - 2*xcg)/2.;
        delayParts12[1] = (-2*mTimestep*q1*q2*Ub - 2*mTimestep*q0*q3*Ub - \
mTimestep*Power(q0,2)*Vb + mTimestep*Power(q1,2)*Vb - \
mTimestep*Power(q2,2)*Vb + mTimestep*Power(q3,2)*Vb + 2*mTimestep*q0*q1*Wb - \
2*mTimestep*q2*q3*Wb - 2*ycg)/2.;
        delayParts13[1] = (2*mTimestep*q0*q2*Ub - 2*mTimestep*q1*q3*Ub - \
2*mTimestep*q0*q1*Vb - 2*mTimestep*q2*q3*Vb - mTimestep*Power(q0,2)*Wb + \
mTimestep*Power(q1,2)*Wb + mTimestep*Power(q2,2)*Wb - \
mTimestep*Power(q3,2)*Wb - 2*zcg)/2.;

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
        delayedPart[8][1] = delayParts8[1];
        delayedPart[9][1] = delayParts9[1];
        delayedPart[10][1] = delayParts10[1];
        delayedPart[11][1] = delayParts11[1];
        delayedPart[12][1] = delayParts12[1];
        delayedPart[13][1] = delayParts13[1];

        //Write new values to nodes
        //Port Pal1
        (*mpND_cal1)=cal1;
        (*mpND_Zcal1)=Zcal1;
        //Port Par1
        (*mpND_car1)=car1;
        (*mpND_Zcar1)=Zcar1;
        //Port Pal12
        (*mpND_cal12)=cal12;
        (*mpND_Zcal12)=Zcal12;
        //Port Par12
        (*mpND_car12)=car12;
        (*mpND_Zcar12)=Zcar12;
        //Port Pal2
        (*mpND_cal2)=cal2;
        (*mpND_Zcal2)=Zcal2;
        //Port Par2
        (*mpND_car2)=car2;
        (*mpND_Zcar2)=Zcar2;
        //Port Pfin
        (*mpND_cfin)=cfin;
        (*mpND_Zcfin)=Zcfin;
        //outputVariables
        (*mpxcg)=xcg;
        (*mpycg)=ycg;
        (*mpzcg)=zcg;
        (*mpvx)=vx;
        (*mpvy)=vy;
        (*mpvz)=vz;
        (*mpPsi)=Psi;
        (*mpThetao)=Thetao;
        (*mpPhi)=Phi;
        (*mpUb)=Ub;
        (*mpVb)=Vb;
        (*mpWb)=Wb;
        (*mpPb)=Pb;
        (*mpQb)=Qb;
        (*mpRb)=Rb;
        (*mpq0)=q0;
        (*mpq1)=q1;
        (*mpq2)=q2;
        (*mpq3)=q3;
        (*mpAlphaAttack)=AlphaAttack;
        (*mpBetaSlip)=BetaSlip;
        (*mpaltitude)=altitude;
        (*mpgfx)=gfx;
        (*mpgfy)=gfy;
        (*mpgfz)=gfz;
        (*mpCL1)=CL1;
        (*mpCd1)=Cd1;
        (*mpFax)=Fax;
        (*mpFaz)=Faz;

        //Update the delayed variabels
        mDelayedPart11.update(delayParts1[1]);
        mDelayedPart21.update(delayParts2[1]);
        mDelayedPart31.update(delayParts3[1]);
        mDelayedPart41.update(delayParts4[1]);
        mDelayedPart51.update(delayParts5[1]);
        mDelayedPart61.update(delayParts6[1]);
        mDelayedPart71.update(delayParts7[1]);
        mDelayedPart81.update(delayParts8[1]);
        mDelayedPart91.update(delayParts9[1]);
        mDelayedPart101.update(delayParts10[1]);
        mDelayedPart111.update(delayParts11[1]);
        mDelayedPart121.update(delayParts12[1]);
        mDelayedPart131.update(delayParts13[1]);

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // AEROAIRCRAFT6DOF_HPP_INCLUDED
